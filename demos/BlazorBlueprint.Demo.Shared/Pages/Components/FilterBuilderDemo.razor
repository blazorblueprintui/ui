@page "/components/filterbuilder"
@using BlazorBlueprint.Demo.Services

<PageTitle>Filter Builder - Blazor Blueprint</PageTitle>

<div class="space-y-8 max-w-7xl">
    <div>
        <div class="space-y-3">
            <h1 class="text-4xl font-bold tracking-tight">Filter Builder</h1>
            <p class="text-xl text-muted-foreground">
                A visual query builder for constructing data filter expressions with AND/OR logic, nested groups, and type-aware value inputs.
            </p>
        </div>
    </div>

    <!-- Overview -->
    <div class="rounded-lg border border-dashed bg-muted/30 p-6 space-y-3">
        <h2 class="text-lg font-semibold">How it works</h2>
        <div class="space-y-2 text-sm text-muted-foreground">
            <p>
                The Filter Builder lets users construct structured filter expressions through an intuitive UI.
                Each filter is a tree of <strong>conditions</strong> (field + operator + value) combined with
                <strong>AND/OR groups</strong> that can be nested to any configurable depth.
            </p>
            <p>
                <strong>Define fields</strong> — Provide an array of <code>FilterField</code> definitions describing the
                filterable columns, their data types, and any enum options. The component automatically selects the
                correct operators and value inputs for each type (text search, numeric comparison, date pickers, multi-select, etc.).
            </p>
            <p>
                <strong>Bind and react</strong> — Use <code>@@bind-Filter</code> for two-way binding to a <code>FilterDefinition</code>
                model. Subscribe to <code>OnFilterChanged</code> to apply filters whenever the user edits a condition.
                Changes are debounced by default (300ms), or you can enable an explicit Apply button for expensive queries.
            </p>
            <p>
                <strong>Evaluate anywhere</strong> — Convert the filter tree into a <code>Func&lt;T, bool&gt;</code>
                for client-side in-memory filtering, or an <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code>
                for server-side queries with EF Core and other IQueryable providers. Filters can also be serialized
                to JSON for storage or transmission.
            </p>
        </div>
    </div>

    <!-- Basic Example -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">Basic Filter Builder</h2>
            <p class="text-sm text-muted-foreground">
                Build flat filters with string, number, date, enum, and boolean fields. The filter is output as JSON below.
            </p>
        </div>
        <BbFilterBuilder @bind-Filter="basicFilter"
                         Fields="@basicFields"
                         MaxDepth="0"
                         OnFilterChanged="HandleBasicFilterChanged" />

        @if (!basicFilter.IsEmpty)
        {
            <div class="rounded-lg border bg-muted/50 p-4">
                <div class="text-sm font-medium mb-2">Filter JSON Output:</div>
                <pre class="text-xs overflow-auto max-h-64 text-muted-foreground">@basicFilterJson</pre>
            </div>
        }
        <CodeBlock Source="Components/FilterBuilder/basic.txt" />
    </div>

    <!-- Nested Groups -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">Nested AND/OR Groups</h2>
            <p class="text-sm text-muted-foreground">
                Create complex queries with nested groups. Click "Add group" to create sub-groups with their own AND/OR logic.
                Each depth level is visually distinguished with a colored left border. Maximum nesting depth is configurable.
            </p>
        </div>
        <BbFilterBuilder @bind-Filter="nestedFilter"
                         Fields="@basicFields"
                         MaxDepth="3" />
        <CodeBlock Source="Components/FilterBuilder/nested-groups.txt" />
    </div>

    <!-- With Apply Button -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">Apply Button Mode</h2>
            <p class="text-sm text-muted-foreground">
                With <code>ShowApplyButton="true"</code>, changes are only applied when the user clicks the Apply button.
                Useful for expensive server-side queries where you want to avoid triggering a request on every keystroke.
            </p>
        </div>
        <BbFilterBuilder @bind-Filter="applyFilter"
                         Fields="@basicFields"
                         ShowApplyButton="true"
                         OnFilterChanged="HandleApplyFilterChanged" />

        @if (applyFilterApplied)
        {
            <BbBadge Variant="BadgeVariant.Default">
                Filter applied with @applyFilter.TotalConditionCount condition(s)
            </BbBadge>
        }
        <CodeBlock Source="Components/FilterBuilder/apply-button.txt" />
    </div>

    <!-- DataTable Integration -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">DataTable Integration</h2>
            <p class="text-sm text-muted-foreground">
                Pair the filter builder with a DataTable for interactive data exploration.
                The filter is compiled to a <code>Func&lt;T, bool&gt;</code> using <code>ToFunc&lt;T&gt;()</code>
                and applied client-side as users modify conditions.
            </p>
        </div>
        <BbFilterBuilder @bind-Filter="tableFilter"
                         Fields="@personFields"
                         OnFilterChanged="HandleTableFilterChanged" />

        <div class="flex items-center gap-2">
            <BbBadge Variant="BadgeVariant.Secondary">
                @filteredPeople.Count of @allPeople.Count records
            </BbBadge>
        </div>

        <BbDataTable TData="Person" Data="@filteredPeople" InitialPageSize="10">
            <Columns>
                <BbDataTableColumn TData="Person" TValue="string" Property="@(p => p.Name)" Header="Name" Sortable />
                <BbDataTableColumn TData="Person" TValue="string" Property="@(p => p.Email)" Header="Email" />
                <BbDataTableColumn TData="Person" TValue="int" Property="@(p => p.Age)" Header="Age" Sortable />
                <BbDataTableColumn TData="Person" TValue="string" Property="@(p => p.Role)" Header="Role" />
                <BbDataTableColumn TData="Person" TValue="string" Property="@(p => p.Status)" Header="Status">
                    <CellTemplate Context="person">
                        <BbBadge Variant="@(person.Status == "Active" ? BadgeVariant.Default : BadgeVariant.Outline)">
                            @person.Status
                        </BbBadge>
                    </CellTemplate>
                </BbDataTableColumn>
                <BbDataTableColumn TData="Person" TValue="bool" Property="@(p => p.IsActive)" Header="Active">
                    <CellTemplate Context="person">
                        @(person.IsActive ? "Yes" : "No")
                    </CellTemplate>
                </BbDataTableColumn>
            </Columns>
        </BbDataTable>
        <CodeBlock Source="Components/FilterBuilder/datatable-integration.txt" />
    </div>

    <!-- LINQ & EF Core Integration -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">LINQ &amp; EF Core Integration</h2>
            <p class="text-sm text-muted-foreground">
                The <code>FilterDefinition</code> model can be converted to executable code for both client-side and server-side scenarios.
            </p>
        </div>
        <div class="rounded-lg border border-dashed bg-muted/30 p-6 space-y-4">
            <div class="space-y-2">
                <h3 class="text-base font-semibold">Client-side — <code>ToFunc&lt;T&gt;()</code></h3>
                <p class="text-sm text-muted-foreground">
                    Compiles the filter tree into a <code>Func&lt;T, bool&gt;</code> delegate using reflection.
                    Ideal for filtering in-memory collections with LINQ-to-Objects.
                </p>
                <pre class="rounded-lg border bg-muted p-4 text-xs leading-relaxed overflow-x-auto"><code>var predicate = filter.ToFunc&lt;Person&gt;(fields);
var results = people.Where(predicate).ToList();</code></pre>
            </div>
            <div class="space-y-2">
                <h3 class="text-base font-semibold">Server-side — <code>ToExpression&lt;T&gt;()</code></h3>
                <p class="text-sm text-muted-foreground">
                    Builds a LINQ <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> that can be passed to
                    EF Core's <code>Where()</code> method. The expression tree is translated to SQL by the database provider,
                    so filtering happens at the database level rather than in application memory.
                </p>
                <pre class="rounded-lg border bg-muted p-4 text-xs leading-relaxed overflow-x-auto"><code>var expression = filter.ToExpression&lt;Person&gt;(fields);
var results = await dbContext.People
    .Where(expression)
    .ToListAsync();</code></pre>
            </div>
            <div class="space-y-2">
                <h3 class="text-base font-semibold">Serialization — <code>ToJson()</code> / <code>FromJson()</code></h3>
                <p class="text-sm text-muted-foreground">
                    Serialize the entire filter tree to JSON for persistence (e.g., saving user-defined filters to a database
                    or transmitting filters between client and server in an API request).
                </p>
                <pre class="rounded-lg border bg-muted p-4 text-xs leading-relaxed overflow-x-auto"><code>// Save
var json = filter.ToJson();

// Restore
var restored = FilterDefinitionExtensions.FromJson(json);</code></pre>
            </div>
        </div>
        <CodeBlock Source="Components/FilterBuilder/linq-expression.txt" />
    </div>

    <!-- Compact Mode -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">Compact Mode</h2>
            <p class="text-sm text-muted-foreground">
                Use <code>Compact="true"</code> for a smaller layout suitable for toolbars and inline placement.
            </p>
        </div>
        <BbFilterBuilder @bind-Filter="compactFilter"
                         Fields="@basicFields"
                         Compact="true"
                         MaxDepth="1" />
        <CodeBlock Source="Components/FilterBuilder/compact.txt" />
    </div>

    <!-- Max Conditions -->
    <div class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">Max Conditions Limit</h2>
            <p class="text-sm text-muted-foreground">
                Limit the total number of conditions with <code>MaxConditions</code>. This example allows a maximum of 5 conditions.
                Once the limit is reached, the "Add condition" and "Add group" buttons are disabled.
            </p>
        </div>
        <BbFilterBuilder @bind-Filter="limitedFilter"
                         Fields="@basicFields"
                         MaxConditions="5" />
        <p class="text-sm text-muted-foreground">
            Conditions: @limitedFilter.TotalConditionCount / 5
        </p>
        <CodeBlock Source="Components/FilterBuilder/max-conditions.txt" />
    </div>

    <!-- API Reference -->
    <section class="space-y-4">
        <div class="space-y-2">
            <h2 class="text-2xl font-semibold">API Reference</h2>
            <p class="text-muted-foreground">Component properties and parameters.</p>
        </div>
        <div class="space-y-4">
            <ApiReference ComponentName="FilterBuilder">
                <ApiParameter Name="Filter" Type="FilterDefinition">
                    The current filter state. Use with @@bind-Filter for two-way binding.
                </ApiParameter>
                <ApiParameter Name="Fields" Type="IEnumerable&lt;FilterField&gt;">
                    The available fields to filter on. Each field defines a name, label, type, and optional options for enum fields.
                </ApiParameter>
                <ApiParameter Name="OnFilterChanged" Type="EventCallback&lt;FilterDefinition&gt;">
                    Callback invoked when the filter changes. Use for side effects like applying filters to data.
                </ApiParameter>
                <ApiParameter Name="MaxDepth" Type="int" Default="3">
                    Maximum nesting depth for filter groups. Set to 0 to disable grouping entirely.
                </ApiParameter>
                <ApiParameter Name="MaxConditions" Type="int?" Default="null">
                    Maximum total conditions allowed across all groups. Null for unlimited.
                </ApiParameter>
                <ApiParameter Name="DefaultOperator" Type="LogicalOperator" Default="And">
                    Default logical operator (AND/OR) for new groups.
                </ApiParameter>
                <ApiParameter Name="ShowApplyButton" Type="bool" Default="false">
                    Show an explicit Apply button instead of auto-applying changes on each edit.
                </ApiParameter>
                <ApiParameter Name="Compact" Type="bool" Default="false">
                    Compact layout mode for inline/toolbar placement with smaller inputs.
                </ApiParameter>
                <ApiParameter Name="Class" Type="string?">
                    Additional CSS classes for the container element.
                </ApiParameter>
            </ApiReference>
        </div>
    </section>
</div>

@code {
    // Data
    private List<Person> allPeople = new();
    private List<Person> filteredPeople = new();

    // Filters
    private FilterDefinition basicFilter = new();
    private FilterDefinition nestedFilter = new();
    private FilterDefinition applyFilter = new();
    private FilterDefinition tableFilter = new();
    private FilterDefinition compactFilter = new();
    private FilterDefinition limitedFilter = new();

    // State
    private string basicFilterJson = "";
    private bool applyFilterApplied;

    // Field definitions for basic demos
    private readonly FilterField[] basicFields = new[]
    {
        new FilterField { Name = "Name", Label = "Name", Type = FilterFieldType.Text },
        new FilterField { Name = "Email", Label = "Email", Type = FilterFieldType.Text },
        new FilterField { Name = "Age", Label = "Age", Type = FilterFieldType.Number },
        new FilterField { Name = "JoinDate", Label = "Join Date", Type = FilterFieldType.Date },
        new FilterField
        {
            Name = "Status", Label = "Status", Type = FilterFieldType.Enum,
            Options = new SelectOption<string>[]
            {
                new("Active", "Active"),
                new("Inactive", "Inactive"),
                new("Pending", "Pending"),
                new("Suspended", "Suspended")
            }
        },
        new FilterField { Name = "IsActive", Label = "Active", Type = FilterFieldType.Boolean }
    };

    // Extended field definitions for DataTable integration
    private readonly FilterField[] personFields = new[]
    {
        new FilterField { Name = "Name", Label = "Name", Type = FilterFieldType.Text },
        new FilterField { Name = "Email", Label = "Email", Type = FilterFieldType.Text },
        new FilterField { Name = "Age", Label = "Age", Type = FilterFieldType.Number },
        new FilterField
        {
            Name = "Role", Label = "Role", Type = FilterFieldType.Enum,
            Options = new SelectOption<string>[]
            {
                new("Admin", "Admin"),
                new("User", "User"),
                new("Guest", "Guest"),
                new("Moderator", "Moderator"),
                new("Manager", "Manager"),
                new("Developer", "Developer"),
                new("Designer", "Designer"),
                new("Analyst", "Analyst")
            }
        },
        new FilterField
        {
            Name = "Status", Label = "Status", Type = FilterFieldType.Enum,
            Options = new SelectOption<string>[]
            {
                new("Active", "Active"),
                new("Inactive", "Inactive"),
                new("Pending", "Pending"),
                new("Suspended", "Suspended")
            }
        },
        new FilterField { Name = "IsActive", Label = "Active", Type = FilterFieldType.Boolean }
    };

    protected override void OnInitialized()
    {
        allPeople = MockDataService.GeneratePersons(100);
        filteredPeople = new List<Person>(allPeople);
    }

    private void HandleBasicFilterChanged(FilterDefinition filter)
    {
        basicFilterJson = filter.IsEmpty ? "" : filter.ToJson();
    }

    private void HandleApplyFilterChanged(FilterDefinition filter)
    {
        applyFilterApplied = !filter.IsEmpty;
    }

    private void HandleTableFilterChanged(FilterDefinition filter)
    {
        if (filter.IsEmpty)
        {
            filteredPeople = new List<Person>(allPeople);
        }
        else
        {
            var predicate = filter.ToFunc<Person>(personFields);
            filteredPeople = allPeople.Where(predicate).ToList();
        }
    }
}
