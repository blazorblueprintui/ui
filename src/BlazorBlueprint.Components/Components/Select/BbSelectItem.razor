@typeparam TValue
@namespace BlazorBlueprint.Components
@implements IDisposable

@* Styled SelectItem wrapper around SelectItem primitive *@
<BlazorBlueprint.Primitives.Select.BbSelectItem TValue="TValue"
                                           Value="Value"
                                           Text="@GetDisplayText()"
                                           Disabled="Disabled"
                                           class="@CssClass">
    <span class="truncate">
        @if (ChildContent is not null)
        {
            @ChildContent
        }
        else
        {
            @GetDisplayText()
        }
    </span>
    @if (IsSelected)
    {
        <svg class="ml-auto h-4 w-4 shrink-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
    }
</BlazorBlueprint.Primitives.Select.BbSelectItem>

@code {
    [CascadingParameter]
    private BlazorBlueprint.Primitives.Select.SelectContext<TValue>? _context { get; set; }

    // ShouldRender tracking fields
    private bool lastIsSelected;
    private bool lastDisabled;

    /// <summary>
    /// Gets or sets the value of this item.
    /// </summary>
    [Parameter, EditorRequired]
    public TValue Value { get; set; } = default!;

    /// <summary>
    /// Gets or sets the display text for this item.
    /// If not provided, will use ChildContent text or Value.ToString().
    /// </summary>
    [Parameter]
    public string? Text { get; set; }

    /// <summary>
    /// Gets or sets additional CSS classes to apply to the item.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Gets or sets the content to be rendered as the item's display text.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets whether this item is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Gets whether this item is currently selected.
    /// </summary>
    private bool IsSelected
    {
        get
        {
            if (_context == null) return false;
            return EqualityComparer<TValue?>.Default.Equals(_context.Value, Value);
        }
    }

    private const string BaseClasses =
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 px-2 text-sm " +
        "outline-none transition-colors " +
        "data-[focused=true]:bg-accent data-[focused=true]:text-accent-foreground " +
        "data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50";

    private const string SelectedClasses =
        BaseClasses + " bg-accent/50 text-accent-foreground";

    /// <summary>
    /// Gets the computed CSS classes for the item.
    /// </summary>
    private string CssClass => string.IsNullOrEmpty(Class)
        ? (IsSelected ? SelectedClasses : BaseClasses)
        : ClassNames.cn(IsSelected ? SelectedClasses : BaseClasses, Class);

    protected override void OnInitialized()
    {
        if (_context != null)
        {
            _context.OnStateChanged += HandleStateChanged;
        }

        // Initialize ShouldRender tracking
        lastIsSelected = IsSelected;
        lastDisabled = Disabled;
    }

    protected override bool ShouldRender()
    {
        var currentIsSelected = IsSelected;

        if (currentIsSelected != lastIsSelected ||
            Disabled != lastDisabled)
        {
            lastIsSelected = currentIsSelected;
            lastDisabled = Disabled;
            return true;
        }

        return false;
    }

    private void HandleStateChanged()
    {
        StateHasChanged();
    }

    /// <summary>
    /// Gets the display text for this item.
    /// Uses Text parameter if provided, otherwise falls back to Value.ToString().
    /// </summary>
    private string? GetDisplayText()
    {
        return Text ?? Value?.ToString();
    }

    public void Dispose()
    {
        if (_context != null)
        {
            _context.OnStateChanged -= HandleStateChanged;
        }
    }
}
