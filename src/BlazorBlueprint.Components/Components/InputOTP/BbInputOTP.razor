@namespace BlazorBlueprint.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using System.Linq.Expressions
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div @ref="_containerRef" id="@EffectiveId" class="@ContainerClass">
    @if (EffectiveName != null)
    {
        <input type="hidden" name="@EffectiveName" value="@Value" />
    }
    @for (int i = 0; i < Length; i++)
    {
        var index = i;
        <input @ref="_inputRefs[index]"
               type="text"
               inputmode="@HtmlInputMode"
               maxlength="1"
               class="@ComputedInputClass"
               value="@GetValueAt(index)"
               disabled="@Disabled"
               @oninput="@(e => HandleInput(index, e))"
               @onkeydown="@(e => HandleKeyDown(index, e))"
               @onfocus="@(() => HandleFocus(index))" />
        @if (ShowSeparator && index < Length - 1 && (index + 1) % GroupSize == 0)
        {
            <div class="@SeparatorClass">
                @if (Separator != null)
                {
                    @Separator
                }
                else
                {
                    <span>-</span>
                }
            </div>
        }
    }
</div>

@code {
    private FieldIdentifier _fieldIdentifier;
    private EditContext? _editContext;

    [CascadingParameter]
    private EditContext? CascadedEditContext { get; set; }

    /// <summary>
    /// The number of OTP digits.
    /// </summary>
    [Parameter]
    public int Length { get; set; } = 6;

    /// <summary>
    /// The current OTP value.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }

    /// <summary>
    /// Event callback when the value changes.
    /// </summary>
    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    /// <summary>
    /// Gets or sets the HTML name attribute for the input elements.
    /// </summary>
    /// <remarks>
    /// When inside an EditForm and not explicitly set, the name is automatically
    /// derived from the ValueExpression (FieldIdentifier) to support SSR form postback.
    /// Individual digit inputs will use the name with an index suffix.
    /// </remarks>
    [Parameter]
    public string? Name { get; set; }

    /// <summary>
    /// Gets or sets an expression that identifies the bound value.
    /// </summary>
    [Parameter]
    public Expression<Func<string?>>? ValueExpression { get; set; }

    /// <summary>
    /// Event callback when all digits are filled.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnComplete { get; set; }

    /// <summary>
    /// Whether the input is disabled.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// Whether to show separators between groups.
    /// </summary>
    [Parameter]
    public bool ShowSeparator { get; set; } = true;

    /// <summary>
    /// Number of digits per group (for separator placement).
    /// </summary>
    [Parameter]
    public int GroupSize { get; set; } = 3;

    /// <summary>
    /// Custom separator content.
    /// </summary>
    [Parameter]
    public RenderFragment? Separator { get; set; }

    /// <summary>
    /// Additional CSS classes for the container.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Additional CSS classes to apply to each individual OTP input box.
    /// </summary>
    [Parameter]
    public string? InputClass { get; set; }

    /// <summary>
    /// Size variant for the input boxes.
    /// </summary>
    [Parameter]
    public InputOTPSize Size { get; set; } = InputOTPSize.Default;

    /// <summary>
    /// Gets or sets the HTML id attribute for the OTP container element.
    /// Auto-generated if not specified.
    /// </summary>
    [Parameter]
    public string? Id { get; set; }

    /// <summary>
    /// Whether to mask the input values with asterisks (*).
    /// Useful for sensitive codes like PINs.
    /// </summary>
    [Parameter]
    public bool Mask { get; set; }

    /// <summary>
    /// The types of characters accepted by the input.
    /// Defaults to <see cref="InputOTPInputMode.Numbers"/>.
    /// </summary>
    [Parameter]
    public InputOTPInputMode InputMode { get; set; } = InputOTPInputMode.Numbers;

    private ElementReference[] _inputRefs = Array.Empty<ElementReference>();
    private string[] _values = Array.Empty<string>();
    private string? _generatedId;
    private ElementReference _containerRef;
    private IJSObjectReference? _jsModule;
    private DotNetObjectReference<BbInputOTP>? _dotNetRef;
    private bool _jsInitialized;
    private bool _disposed;

    protected override void OnInitialized()
    {
        _inputRefs = new ElementReference[Length];
        _values = new string[Length];

        if (!string.IsNullOrEmpty(Value))
        {
            for (int i = 0; i < Math.Min(Value.Length, Length); i++)
            {
                _values[i] = Value[i].ToString();
            }
        }
    }

    protected override void OnParametersSet()
    {
        if (_values.Length != Length)
        {
            _inputRefs = new ElementReference[Length];
            _values = new string[Length];
        }

        if (!string.IsNullOrEmpty(Value))
        {
            for (int i = 0; i < Length; i++)
            {
                _values[i] = i < Value.Length ? Value[i].ToString() : "";
            }
        }

        if (CascadedEditContext != null && ValueExpression != null)
        {
            _editContext = CascadedEditContext;
            _fieldIdentifier = FieldIdentifier.Create(ValueExpression);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_jsInitialized)
        {
            try
            {
                _jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import",
                    "./_content/BlazorBlueprint.Components/js/input-otp.js");
                _dotNetRef = DotNetObjectReference.Create(this);
                await _jsModule.InvokeVoidAsync("initialize", _containerRef, _dotNetRef, EffectiveId);
                _jsInitialized = true;
            }
            catch (Exception ex) when (ex is JSDisconnectedException or TaskCanceledException or ObjectDisposedException)
            {
                // Expected during circuit disconnect in Blazor Server
            }
            catch (InvalidOperationException)
            {
                // JS interop not available during prerendering
            }
        }
    }

    private string GetValueAt(int index)
    {
        var val = index < _values.Length ? _values[index] ?? "" : "";
        return Mask && !string.IsNullOrEmpty(val) ? "*" : val;
    }

    private async Task HandleInput(int index, ChangeEventArgs e)
    {
        var inputValue = e.Value?.ToString() ?? "";

        if (!string.IsNullOrEmpty(inputValue) && !IsCharAllowed(inputValue[0]))
        {
            return;
        }

        _values[index] = inputValue.Length > 0 ? inputValue[0].ToString() : "";

        var newValue = string.Join("", _values);
        await ValueChanged.InvokeAsync(newValue);

        if (_editContext != null && ValueExpression != null && _fieldIdentifier.FieldName != null)
        {
            _editContext.NotifyFieldChanged(_fieldIdentifier);
        }

        // Move to next input if value entered
        if (!string.IsNullOrEmpty(_values[index]) && index < Length - 1)
        {
            await FocusInput(index + 1);
        }

        // Check if complete
        if (newValue.Length == Length && !newValue.Contains(""))
        {
            var completeValue = string.Join("", _values.Where(v => !string.IsNullOrEmpty(v)));
            if (completeValue.Length == Length)
            {
                await OnComplete.InvokeAsync(completeValue);
            }
        }
    }

    private async Task HandleKeyDown(int index, KeyboardEventArgs e)
    {
        if (e.Key == "Backspace" && string.IsNullOrEmpty(_values[index]) && index > 0)
        {
            // Move to previous input on backspace when current is empty
            await FocusInput(index - 1);
        }
        else if (e.Key == "ArrowLeft" && index > 0)
        {
            await FocusInput(index - 1);
        }
        else if (e.Key == "ArrowRight" && index < Length - 1)
        {
            await FocusInput(index + 1);
        }
    }

    [JSInvokable]
    public async Task OnPasteJs(string pastedText)
    {
        if (_disposed) return;

        // Extract only allowed characters
        var filtered = string.Concat(pastedText.Where(IsCharAllowed));

        if (string.IsNullOrEmpty(filtered))
        {
            return;
        }

        // Fill values from the start, up to Length; clear any slots beyond pasted chars
        for (int i = 0; i < Length; i++)
        {
            _values[i] = i < filtered.Length ? filtered[i].ToString() : "";
        }

        var newValue = string.Join("", _values);
        await ValueChanged.InvokeAsync(newValue);

        if (_editContext != null && ValueExpression != null && _fieldIdentifier.FieldName != null)
        {
            _editContext.NotifyFieldChanged(_fieldIdentifier);
        }

        // Focus the last filled box, or the next empty box
        var focusIndex = Math.Min(filtered.Length, Length - 1);
        await FocusInput(focusIndex);

        // Fire OnComplete if all slots are filled
        var completeValue = string.Join("", _values.Where(v => !string.IsNullOrEmpty(v)));
        if (completeValue.Length == Length)
        {
            await OnComplete.InvokeAsync(completeValue);
        }

        StateHasChanged();
    }

    private void HandleFocus(int index)
    {
        // Select content on focus
    }

    private async Task FocusInput(int index)
    {
        if (index >= 0 && index < _inputRefs.Length)
        {
            try
            {
                await _inputRefs[index].FocusAsync();
            }
            catch
            {
                // Ignore focus errors
            }
        }
    }

    /// <summary>
    /// Gets the effective name attribute, falling back to the FieldIdentifier name when inside an EditForm.
    /// </summary>
    private string? EffectiveName => Name ?? (_editContext != null && _fieldIdentifier.FieldName != null ? _fieldIdentifier.FieldName : null);

    private string EffectiveId => Id ?? (_generatedId ??= $"otp-{Guid.NewGuid().ToString("N")[..8]}");

    private bool IsCharAllowed(char c) => InputMode switch
    {
        InputOTPInputMode.Letters => char.IsLetter(c),
        InputOTPInputMode.LettersAndNumbers => char.IsLetterOrDigit(c),
        _ => char.IsDigit(c)
    };

    private string HtmlInputMode => InputMode switch
    {
        InputOTPInputMode.Letters => "text",
        InputOTPInputMode.LettersAndNumbers => "text",
        _ => "numeric"
    };

    private string SizeClasses => Size switch
    {
        InputOTPSize.Small => "h-8 w-8 text-sm",
        InputOTPSize.Default => "h-10 w-10 text-base",
        InputOTPSize.Large => "h-12 w-12 text-lg",
        _ => "h-10 w-10 text-base"
    };

    private string ContainerClass => ClassNames.cn(
        "flex items-center gap-2",
        Class
    );

    private string ComputedInputClass => ClassNames.cn(
        "flex items-center justify-center rounded-md border border-input bg-background text-center font-medium",
        "focus:outline-none",
        "disabled:cursor-not-allowed disabled:opacity-50",
        SizeClasses,
        InputClass
    );

    private string SeparatorClass => "flex items-center justify-center text-muted-foreground";

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        if (_jsInitialized && _jsModule != null)
        {
            try
            {
                await _jsModule.InvokeVoidAsync("dispose", EffectiveId);
                await _jsModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }

        _dotNetRef?.Dispose();
    }
}
