@namespace BlazorUI.Primitives.Table
@typeparam TData where TData : class
@inject IJSRuntime JSRuntime

<tr @ref="_elementRef"
    role="row"
    aria-selected="@(IsSelected ? "true" : "false")"
    tabindex="@(IsSelectable ? 0 : -1)"
    class="@Class"
    @onclick="HandleClick"
    @onkeydown="HandleKeyDown"
    @attributes="AdditionalAttributes">
    @ChildContent
</tr>

@code {
    private ElementReference _elementRef;
    private bool _spaceKeyHandlerAttached = false;

    [CascadingParameter]
    private TableContext<TData> Context { get; set; } = default!;

    /// <summary>
    /// The data item for this row.
    /// </summary>
    [Parameter]
    public TData? Item { get; set; }

    /// <summary>
    /// Child content for the row (typically TableCell components).
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Additional CSS classes to apply to the tr element.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    /// <summary>
    /// Additional attributes to apply to the tr element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private bool IsSelected => Item != null && Context != null && Context.IsSelected(Item);

    private bool IsSelectable => Context != null && Context.SelectionMode != SelectionMode.None;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsSelectable && !_spaceKeyHandlerAttached)
        {
            try
            {
                // Attach event listener in capture phase to prevent Space from scrolling
                // This runs before Blazor's event handler, allowing us to preventDefault
                await JSRuntime.InvokeVoidAsync("eval", @"
                    (function(element) {
                        element.addEventListener('keydown', function(e) {
                            // Check both modern and legacy key identifiers
                            if (e.key === ' ' || e.keyCode === 32) {
                                e.preventDefault();
                            }
                        }, { capture: true });
                    })(arguments[0])
                ", _elementRef);
                _spaceKeyHandlerAttached = true;
            }
            catch
            {
                // Silently fail during prerendering
            }
        }
    }

    private void HandleClick()
    {
        if (Item != null && IsSelectable)
        {
            Context.ToggleRowSelection(Item);
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (!IsSelectable) return;

        switch (e.Key)
        {
            case "Enter":
            case " ":
                if (Item != null)
                {
                    Context.ToggleRowSelection(Item);
                }
                break;

            case "ArrowUp":
                await MoveFocusToPreviousRow();
                break;

            case "ArrowDown":
                await MoveFocusToNextRow();
                break;
        }
    }

    private async Task MoveFocusToPreviousRow()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                (function(element) {
                    let prevRow = element.previousElementSibling;
                    while (prevRow && prevRow.getAttribute('tabindex') === '-1') {
                        prevRow = prevRow.previousElementSibling;
                    }
                    if (prevRow && prevRow.getAttribute('tabindex') === '0') {
                        prevRow.focus();
                    }
                })(arguments[0])
            ", _elementRef);
        }
        catch
        {
            // Ignore JS interop errors (e.g., during prerendering)
        }
    }

    private async Task MoveFocusToNextRow()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                (function(element) {
                    let nextRow = element.nextElementSibling;
                    while (nextRow && nextRow.getAttribute('tabindex') === '-1') {
                        nextRow = nextRow.nextElementSibling;
                    }
                    if (nextRow && nextRow.getAttribute('tabindex') === '0') {
                        nextRow.focus();
                    }
                })(arguments[0])
            ", _elementRef);
        }
        catch
        {
            // Ignore JS interop errors (e.g., during prerendering)
        }
    }
}
